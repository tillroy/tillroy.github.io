---
title:  "Intersection Over Union"
tags: [iou]
---

# Intersection Over Union aka IoU

A lot of blog post already avalible which are related to the IoU topic. Current post does not prettend to be treasure chest of  but here I've wrote down couple of notes which helped me understand the angorithm better and implement it bymyself.

## Goal
1. Understand idea behind the algoritm
2. Implement algoritm from scratch

## Idea behid the algoritm
The aim of IoU algoritm is to show how bound box(`A`) is simmilar or different from bound box (`B`). IoU produse one value in range from 0 to 1. Where 0 means totaly differnt boud boxes and 1 means - this is the same bound box. In other words IoU algoritm is just a simmilarity function with 2 arguments `A` and `B` that returns float value.
We could define this function in next way:

```python
def iou(bbox_a:list, bbox_b:list)->float:
    # calculate IoU here
    pass
```

Let's define two variable corespondint to bounding boxes and use `[xmin, xmax, ymin, ymax]` convetion for bound box definition:

```python
bbox_a = [0, 512, 0, 512]
bbox_b = [256, 768, 256, 768]
```

Each bbox could be shown as rectangle area which could be calculated as `rectangle_width * rectangle_height`. Height and width could be calculated from bbox(e.g. `xmax-xmin`) if neccesary, but let's skip it for a current momment.

Intersection is the area where two bboxes are overlaped

Based of algorith name we have to find 2 values:
- ***intersection*** of two bboxes(the area where two bboxes are overlaped)
- ***union*** of two bboxes(bbox areas sum - intersection)

We know how to calculate area of the rectangle, but it will give us only sum or bbox areas but not intersection nor union.

## Implement algoritm from scratch
If we find ***intersection*** we will have all neccesary for algoritm implemetation. We could make it in different ways, but here is one of most elegant ways in my oppinion[[1](https://github.com/experiencor/keras-yolo2/blob/4e8c85ce02435f136d4f4cfe930b4ccb759fbaf8/utils.py#L182)]

<!-- add image here -->
Based on image above we could have two ways how bboxes are related to each other:

1.`bbox_b` is lefter than `bbox_a`
2.`bbox_b` is righter than `bbox_a`

This way is righ but it does not save us when boxes are righter or lefter but not overlaped. Let's fix it:

1.`bbox_b` is lefter than `bbox_a`
1.1 bboxes area are not overlapped
1.2 bboxes area are overlapped
2.`bbox_b` is righter than `bbox_a`
2.1 bboxes area are not overlapped
2.2 bboxes area are overlapped

But wait, boxes also could be higher and lower to each other. That is true. Let decrise our space from 2D to 1D and make calculations only for one axis and rewrite statements above which will better reflect process. If we work only with one axis we can't treat values as lefter or righer any more, because it could leads to misunderstanding in 2D space in feature. Let use ***smaller*** and ***bigger*** words instead. Also let change `bbox` to `value` and `box area` to `interval`.

1.`value_b` is smaller than `value_a`
1.1 intervals are not overlapped
1.2 intervals are overlapped
2.`value_b` is bigger than `value_a`
2.1 intervals are not overlapped
2.2 intervals are overlapped

Go ahead and create new our function in code which will reflect statements above:

```python
def get_axis_overlap(v1:int, v2:int, v3:int, v4:int)->int:
    # v values corespons to bouth bbox values on the same axis.
    # For example at X asis it will be x1, x2, x3, x4 respectively
    # x1 and x2 corresponds to bbox_a and x3 and x4 corresponds to bbox_b

    # value from bbox_b is smaller than value from bbox_a
    if v3 < v1:
        if v4 < v1:
            # intervals are not overlapped
            pass
        else:
            # bboxes are overlapped
            pass
    else:
        # value from bbox_b is bigger than value from bbox_a
        pass
```